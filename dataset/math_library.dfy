// This code is generated by Claude4.5 Opus.

// STUB CODE STARTS==============
// STUB CODE FOR REAL MATH FUNCTIONS AND LEMMAS

ghost function power(x: real, n: nat) : (r: real) 
ensures (x != 0.0) ==> (r != 0.0)
{
    if n == 0 then 1.0 else x * power(x, n-1)
}

function {:extern} abs(x: real): (r: real)
    ensures r >= 0.0
    ensures r == x || r == -x



function {:extern} max(x: real, y: real): (r: real)
    ensures  (x <= r) && (y <= r)
    ensures  (x == r) || (y == r)



function {:extern} min(x: real, y: real): (r: real)
    ensures  (x >= r) && (y >= r)
    ensures  (x == r) || (y == r)



function {:extern} sin(x: real): (r: real)
    ensures -1.0 <= r <= 1.0
    ensures (x == 0.0) ==> (r == 0.0)



function {:extern} cos(x: real): (r: real)
    ensures -1.0 <= r <= 1.0
    ensures (x == 0.0) ==> (r == 1.0)



function {:extern} pi(x: real): (r: real)
    requires x >= 0.0
    ensures r <= 3.141592653589793 * x
    ensures r >= 3.141592653589790 * x



function {:extern} pow(x: real, d: real): (r: real)
    requires (x >= 0.0)
    requires (x != 0.0) || (d >= 0.0)
    ensures (r >= 0.0)
    ensures (x > 0.0) ==> (r > 0.0)
    ensures (d == 0.0) ==> (r == 1.0)
    ensures ((x >= 1.0) && (d >= 0.0)) ==> (r >= 1.0)
    ensures ((x >= 1.0) && (d <= 0.0)) ==> (r <= 1.0)ensures ((x <= 1.0) && (d >= 0.0)) ==> (r <= 1.0)
    ensures ((x <= 1.0) && (d <= 0.0)) ==> (r >= 1.0)



function {:extern} powInt(x: real, d: int): (r: real)
    requires (x != 0.0) || (d >= 0)
    ensures (x != 0.0) ==> (r != 0.0)
    ensures (d == 0) ==> r == 1.0
    ensures (d < 0) ==> r == 1.0 / power(x, -d)
    ensures (d >= 0) ==> r == power(x, d)
    ensures (d % 2 == 0) ==> r >= 0.0
    ensures (x >= 0.0) ==> r >= 0.0
    ensures (x < 0.0) && (d % 2 == 1) ==> r < 0.0
    ensures (x >= 0.0) ==> (r == pow(x, d as real))



function {:extern} sqrt(x: real): (r: real)
    requires x >= 0.0
    ensures r >= 0.0
    ensures r * r == x
    ensures r == pow(x, 0.5)



function {:extern} wave(amplitude: real, oscillation: real): (r: real)
    requires amplitude >= 0.0
    requires (oscillation >= -1.0) && (oscillation <= 1.0)
    ensures r == amplitude * oscillation
    ensures (r >= -amplitude) && (r <= amplitude)



function {:extern} exp(x: real): (r: real)
    ensures r >= 0.0
    ensures (x <= 0.0) ==> (r <= 1.0)
    ensures (x >= 0.0) ==> (r >= 1.0)
    ensures (x == 1.0) ==> (r >= 2.71) && (r <= 2.72)
    ensures r >= (1.0 + x)



function {:extern} log(x: real): (r: real)
    requires x > 0.0
    ensures (x >= 1.0) ==> (r >= 0.0)
    ensures (x <= 1.0) ==> (r <= 0.0)
    ensures (x == 1.0) ==> (r == 0.0)
    ensures (x >= exp(1.0)) ==> (r >= 1.0)


// Definition of lemmas for use in verification

lemma {:axiom} lemma_Mult_pos(x: real, y: real)
    requires 0.0 <= x
    requires 0.0 <= y
    ensures 0.0 <= x * y



lemma {:axiom} lemma_wave_multiplication(wave1: real, amplitude1: real, wave2: real, amplitude2: real)
    requires amplitude1 >= 0.0
    requires amplitude2 >= 0.0
    requires -amplitude1 <= wave1 <= amplitude1
    requires -amplitude2 <= wave2 <= amplitude2
    ensures -(amplitude1*amplitude2) <= wave1*wave2 <= (amplitude1*amplitude2)



lemma {:axiom} lemma_Mult_symbolic_ub(x: real, y: real, yub: real)
    requires 0.0 <= x
    requires y <= yub
    ensures x * y <= x * yub



lemma {:axiom} lemma_Mult_symbolic_lb(x: real, y: real, ylb: real)
    requires 0.0 <= x
    requires ylb <= y
    ensures x * ylb <= x * y



lemma {:axiom} lemma_Mult_symbolic_bounds(x: real, y: real, ylb: real, yub: real)
    requires 0.0 <= x
    requires ylb <= y
    requires y <= yub
    ensures x * y <= x * yub
    ensures x * ylb <= x * y



lemma {:axiom} lemma_square(x: real, r: real)
    requires r == x * x
    ensures r >= 0.0



lemma {:axiom} lemma_interval_bounds_multiplication(x: real, xlb: real, xub: real, y: real, ylb: real, yub: real)
    ensures min(min(xlb*ylb, xlb*yub), min(xub*ylb, xub*yub)) <= x * y
    ensures max(max(xlb*ylb, xlb*yub), max(xub*ylb, xub*yub)) >= x * y



lemma {:axiom} lemma_pow_comparator(x: real, d1: real, d2: real)
    requires (x != 0.0) || ((d1 >= 0.0) && (d2 >= 0.0))
    ensures (0.0 <= x <= 1.0) && (d1 <= d2) ==> (pow(x, d1) >= pow(x, d2))
    ensures (1.0 <= x) && (d1 <= d2) ==> (pow(x, d1) <= pow(x, d2))



lemma {:axiom} lemma_pow_pos(x: real, d: int)
    ensures (x != 0.0 || (d >= 0)) && (d % 2) == 0 ==> (powInt(x, d) >= 0.0)



lemma {:axiom} lemma_powInt_division(r: real, x: real, d: int)
    requires (x) != 0.0 && (r != 0.0)
    ensures (r == powInt(x, d)) <==> ((1.0 / r) == powInt(x, -d))



lemma {:axiom} lemma_pow_division(r: real, x: real, d: real)
    requires (x) > 0.0 && (r != 0.0)
    ensures (r == pow(x, d)) <==> ((1.0 / r) == pow(x, -d))



lemma {:axiom} lemma_pow_mult(x: real, r: real)
    ensures r == x <==>  r == powInt(x, 1)
    ensures (x >= 0.0) ==> (r == x <==> r == pow(x, 1.0))
    ensures (x >= 0.0) ==> (r == x*x <==> r == pow(x, 2.0))
    ensures (x >= 0.0) ==> (r == x*x*x <==> r == pow(x, 3.0))
    ensures r == x*x <==> r == powInt(x, 2)
    ensures r == x*x*x <==> r == powInt(x, 3)



lemma {:axiom} lemma_pow_monotonicity(x1: real, x2: real, d: real)
    requires 0.0 <= x1 <= x2
    requires (d < 0.0) ==> (x1 > 0.0)
    ensures (d >= 0.0) ==> (pow(x1, d) <= pow(x2, d))
    ensures (d <= 0.0) ==> (pow(x1, d) >= pow(x2, d))



lemma {:axiom} lemma_powInt_monotonicity(x1: real, x2: real, d: int)
    requires 0.0 <= x1 <= x2
    requires (d < 0) ==> (x1 > 0.0)
    ensures (d >= 0) ==> (powInt(x1, d) <= powInt(x2, d))
    ensures (d <= 0) ==> (powInt(x1, d) >= powInt(x2, d))



lemma {:axiom} lemma_exp_pow_relationship(x: real)
    ensures exp(x) == pow(exp(1.0), x)



lemma {:axiom} lemma_exp_log_relationship(x: real, r: real)
    requires x > 0.0
    ensures (r == log(x)) <==> (exp(r) == x)

//new lemmas
lemma {:axiom} lemma_strict_mult(a: real, b: real, c: real)
    requires a < b
    requires c > 0.0
    ensures a * c < b * c

lemma {:axiom} lemma_strict_div(a: real, b: real, c: real)
    requires a < b
    requires c > 0.0
    ensures a / c < b / c

// 1. Axiom to prove multiplying two strictly positive numbers is strictly positive
lemma {:axiom} lemma_strict_mult_pos(a: real, b: real)
    requires a > 0.0
    requires b > 0.0
    ensures a * b > 0.0

// 2. Axiom to prove division of positive numbers remains positive
lemma {:axiom} lemma_div_pos(a: real, b: real)
    requires a >= 0.0
    requires b > 0.0
    ensures a / b >= 0.0

//now the new lemmas
// Axiom for strict division positivity (positive / positive > 0)
lemma {:axiom} lemma_strict_div_pos(a: real, b: real)
    requires a > 0.0
    requires b > 0.0
    ensures a / b > 0.0
    
// Axiom to prove the square of a non-zero number is strictly positive
lemma {:axiom} lemma_square_strictly_pos(x: real)
    requires x != 0.0
    ensures x * x > 0.0
    
// Axiom for negative * positive = negative
lemma {:axiom} lemma_mult_neg_pos_is_neg(a: real, b: real)
    requires a < 0.0
    requires b > 0.0
    ensures a * b < 0.0
    
// Axiom for positive / negative = negative
lemma {:axiom} lemma_div_pos_neg_is_neg(a: real, b: real)
    requires a > 0.0
    requires b < 0.0
    ensures a / b < 0.0

// ---- Axioms for Polynomial Algebra & Curves ----

// Axioms for even/odd powers and negative numbers
lemma {:axiom} lemma_even_pow4(x: real)
    ensures (-x) * (-x) * (-x) * (-x) == x * x * x * x

lemma {:axiom} lemma_odd_pow3(x: real)
    ensures (-x) * (-x) * (-x) == -(x * x * x)

lemma {:axiom} lemma_square_even(y: real)
    ensures (-y) * (-y) == y * y

// Axiom for Constraint 4: x^4 - x^3 is monotonically decreasing for x <= 0
lemma {:axiom} lemma_poly_mono_x(x1: real, x2: real)
    requires x1 < x2 <= 0.0
    ensures (x1*x1*x1*x1 - x1*x1*x1) > (x2*x2*x2*x2 - x2*x2*x2)

// Axiom for Constraint 5: y^2/2 - y is monotonically increasing for y >= 1
lemma {:axiom} lemma_poly_mono_y_inc(y1: real, y2: real)
    requires 1.0 <= y1 < y2
    ensures (y1*y1)/2.0 - y1 < (y2*y2)/2.0 - y2

// Axiom for Constraint 6: y^2/2 - y is monotonically decreasing for y <= 1
lemma {:axiom} lemma_poly_mono_y_dec(y1: real, y2: real)
    requires y1 < y2 <= 1.0
    ensures (y1*y1)/2.0 - y1 > (y2*y2)/2.0 - y2

// Axiom to ensure squares are always non-negative
lemma {:axiom} lemma_square_non_negative(x: real)
    ensures x * x >= 0.0

// Axiom to prove an upper bound for division
lemma {:axiom} lemma_div_upper_bound(a: real, b: real, c: real)
    requires b > 0.0
    requires a <= b * c
    ensures a / b <= c

// Axioms to prove cubed numbers preserve their signs
lemma {:axiom} lemma_cube_neg(x: real)
    requires x <= 0.0
    ensures x * x * x <= 0.0

lemma {:axiom} lemma_cube_pos(x: real)
    requires x >= 0.0
    ensures x * x * x >= 0.0

// Axioms for multiplication with non-strict inequalities
lemma {:axiom} lemma_mult_le_zero(a: real, b: real)
    requires a <= 0.0
    requires b <= 0.0
    ensures a * b >= 0.0

lemma {:axiom} lemma_mult_le_ge_zero(a: real, b: real)
    requires a <= 0.0
    requires b >= 0.0
    ensures a * b <= 0.0

// Axiom to teach Dafny how to factor this specific cubic polynomial
lemma {:axiom} lemma_factor_cubic(x: real)
    ensures (x * x * x) + (x * x) + x == x * ((x * x) + x + 1.0)

// Axiom to prove the quadratic component is always strictly positive
lemma {:axiom} lemma_quad_always_pos(x: real)
    ensures (x * x) + x + 1.0 > 0.0

//new lemmas to be added 28th feb
// Axiom to teach Dafny how to factor the nguyen3 quintic polynomial
lemma {:axiom} lemma_factor_quintic(x: real)
    ensures (x*x*x*x*x) + (x*x*x*x) + (x*x*x) + (x*x) + x == x * ((x*x*x*x) + (x*x*x) + (x*x) + x + 1.0)

// Axiom to prove the 4th-degree component is always strictly positive
lemma {:axiom} lemma_poly4_always_pos(x: real)
    ensures (x*x*x*x) + (x*x*x) + (x*x) + x + 1.0 > 0.0

// Axioms for 5th power signs
lemma {:axiom} lemma_odd_pow5(x: real)
    ensures (-x) * (-x) * (-x) * (-x) * (-x) == -(x * x * x * x * x)

lemma {:axiom} lemma_pow5_pos(x: real)
    requires x > 0.0
    ensures (x * x * x * x * x) > 0.0

// Axioms for nguyen4 polynomial bounds and factorization
lemma {:axiom} lemma_factor_nguyen4(x: real)
    ensures (x*x*x*x*x*x) + (x*x*x*x*x) + (x*x*x*x) + (x*x*x) + (x*x) + x == x * ((x*x*x*x*x) + (x*x*x*x) + (x*x*x) + (x*x) + x + 1.0)

lemma {:axiom} lemma_poly5_always_pos_for_pos_x(x: real)
    requires x > 0.0
    ensures (x*x*x*x*x) + (x*x*x*x) + (x*x*x) + (x*x) + x + 1.0 > 0.0

// Axiom to teach Dafny the absolute global minimum of this specific 6th-degree polynomial
lemma {:axiom} lemma_nguyen4_lower_bound(x: real)
    ensures (x*x*x*x*x*x) + (x*x*x*x*x) + (x*x*x*x) + (x*x*x) + (x*x) + x >= -0.75

// Axiom for 6th power sign
lemma {:axiom} lemma_even_pow6(x: real)
    ensures (-x)*(-x)*(-x)*(-x)*(-x)*(-x) == (x*x*x*x*x*x)

// Axioms for the pagie1 rational function bounds
lemma {:axiom} lemma_pow4_strictly_pos(x: real)
    requires x != 0.0
    ensures (x * x * x * x) > 0.0

lemma {:axiom} lemma_inverse_strictly_pos(x: real)
    requires x > 0.0
    ensures 1.0 / x > 0.0

// Axiom defining the bounds of the specific fraction: 0 < 1 / (1 + positive) < 1
lemma {:axiom} lemma_pagie_fraction_bounds(x_inv: real)
    requires x_inv > 0.0
    ensures 1.0 / (1.0 + x_inv) > 0.0
    ensures 1.0 / (1.0 + x_inv) < 1.0

// Axiom to prove fraction upper bounds when the denominator is larger than a numerator factor
// Mathematically: if den >= b, then (a * b) / den <= a
lemma {:axiom} lemma_fraction_upper_bound(a: real, b: real, den: real)
    requires a > 0.0
    requires b > 0.0
    requires den >= b
    requires den > 0.0
    ensures (a * b) / den <= a

// Axioms to bypass Dafny's NLA associativity blocks for 3-variable fractions
lemma {:axiom} lemma_res3_bound_r1(r1: real, r2: real, r3: real, den: real)
    requires r1 > 0.0 && r2 > 0.0 && r3 > 0.0
    requires den >= r2 * r3
    requires den > 0.0
    ensures (r1 * r2 * r3) / den <= r1

lemma {:axiom} lemma_res3_bound_r2(r1: real, r2: real, r3: real, den: real)
    requires r1 > 0.0 && r2 > 0.0 && r3 > 0.0
    requires den >= r1 * r3
    requires den > 0.0
    ensures (r1 * r2 * r3) / den <= r2

lemma {:axiom} lemma_res3_bound_r3(r1: real, r2: real, r3: real, den: real)
    requires r1 > 0.0 && r2 > 0.0 && r3 > 0.0
    requires den >= r1 * r2
    requires den > 0.0
    ensures (r1 * r2 * r3) / den <= r3


function {:extern} bounded_param(lb: real, ub: real, initial: real): (r: real)
    requires lb <= ub
    requires initial >= lb
    requires initial <= ub
    ensures r >= lb
    ensures r <= ub



function {:extern} lower_bounded_param(lb: real, initial: real): (r: real)
    requires initial >= lb
    ensures r >= lb



function {:extern} upper_bounded_param(ub: real, initial: real): (r: real)
    requires initial <= ub
    ensures r <= ub


// Teaches Dafny the ordering, positivity, and zero-states of real-valued powers
lemma {:axiom} lemma_pow_real_properties(x: real)
    requires x >= 0.0
    
    // Rule A: Evaluating at zero
    ensures (x == 0.0) ==> (pow(x, 2.0) == 0.0 && pow(x, 3.0) == 0.0 && pow(x, 4.0) == 0.0 && pow(x, 5.0) == 0.0)
    
    // Rule B: Positivity
    ensures pow(x, 2.0) >= 0.0 && pow(x, 3.0) >= 0.0 && pow(x, 4.0) >= 0.0 && pow(x, 5.0) >= 0.0
    
    // Rule C: Monotonicity (Growth) for x >= 1
    ensures (x >= 1.0) ==> (x <= pow(x, 2.0) <= pow(x, 3.0) <= pow(x, 4.0) <= pow(x, 5.0))
    
    // Rule D: Monotonicity (Decay) for 0 <= x <= 1
    ensures (x <= 1.0) ==> (pow(x, 5.0) <= pow(x, 4.0) <= pow(x, 3.0) <= pow(x, 2.0) <= x)


// Teaches Dafny that the product of two bounded fractional values is bounded
lemma {:axiom} lemma_MulBounds_fractional(a: real, b: real)
    requires -1.0 <= a <= 1.0
    requires -1.0 <= b <= 1.0
    ensures -1.0 <= a * b <= 1.0


lemma {:axiom} lemma_MulBounds(a: real, b: real)
    requires -1.0 <= a <= 1.0
    requires -1.0 <= b <= 1.0
    ensures -1.0 <= a * b <= 1.0

lemma {:axiom} lemma_Parity_Powers(x: real)
    ensures powInt(-x, 2) == powInt(x, 2)
    ensures powInt(-x, 3) == -powInt(x, 3)
    ensures powInt(-x, 4) == powInt(x, 4)
    ensures powInt(-x, 5) == -powInt(x, 5)
    ensures powInt(-x, 6) == powInt(x, 6)

// Specific lower bounds for the Nguyen polynomial benchmarks
lemma {:axiom} lemma_Polynomial_nguyen3_bounds(x: real)
    ensures (x < 0.0) ==> (powInt(x, 5) + powInt(x, 4) + powInt(x, 3) + powInt(x, 2) + x <= 0.0)


lemma {:axiom} lemma_Polynomial_nguyen4_bounds(x: real)
    ensures (x < 0.0) ==> (powInt(x, 6) + powInt(x, 5) + powInt(x, 4) + powInt(x, 3) + powInt(x, 2) + x >= -0.75)


lemma {:axiom} lemma_kepler_rules(m1: real, m2: real, d: real, d_b: real, G: real)
    requires m1 > 0.0 && m2 > 0.0 && d > 0.0 && G > 0.0 && d_b > 0.0
    // Constraint A: Positivity
    ensures (if (G * (m1 + m2) == 0.0) || ((4.0 * 3.14159 * 3.14159 * d * d * d) / (G * (m1 + m2)) < 0.0) then 0.0 else sqrt((4.0 * 3.14159 * 3.14159 * d * d * d) / (G * (m1 + m2)))) > 0.0
    // Constraint C: Monotonicity (Larger distance = longer period)
    ensures (d_b > d) ==> (
        (if (G * (m1 + m2) == 0.0) || ((4.0 * 3.14159 * 3.14159 * d_b * d_b * d_b) / (G * (m1 + m2)) < 0.0) then 0.0 else sqrt((4.0 * 3.14159 * 3.14159 * d_b * d_b * d_b) / (G * (m1 + m2)))) >
        (if (G * (m1 + m2) == 0.0) || ((4.0 * 3.14159 * 3.14159 * d * d * d) / (G * (m1 + m2)) < 0.0) then 0.0 else sqrt((4.0 * 3.14159 * 3.14159 * d * d * d) / (G * (m1 + m2))))
    )


lemma {:axiom} lemma_einstein_rules(v: real, v_b: real, c: real)
    requires 0.0 <= v < c && 0.0 <= v_b < c && c > 0.0
    // Constraint A: Zero State
    ensures (v == 0.0) ==> ((if (c * c == 0.0) || (1.0 - ((v * v) / (c * c)) < 0.0) then 0.0 else sqrt(1.0 - ((v * v) / (c * c))) - 1.0) == 0.0)
    // Constraint B: Bounds
    ensures -1.0 <= (if (c * c == 0.0) || (1.0 - ((v * v) / (c * c)) < 0.0) then 0.0 else sqrt(1.0 - ((v * v) / (c * c))) - 1.0) <= 0.0
    // Constraint C: Monotonic Decreasing
    ensures (v_b > v) ==> (
        (if (c * c == 0.0) || (1.0 - ((v_b * v_b) / (c * c)) < 0.0) then 0.0 else sqrt(1.0 - ((v_b * v_b) / (c * c))) - 1.0) <
        (if (c * c == 0.0) || (1.0 - ((v * v) / (c * c)) < 0.0) then 0.0 else sqrt(1.0 - ((v * v) / (c * c))) - 1.0)
    )


lemma {:axiom} lemma_langmuir1_rules(p: real, p_b: real, q_max: real, K_a: real)
    requires p >= 0.0 && p_b >= 0.0 && q_max > 0.0 && K_a > 0.0
    // Constraints A & B: Positivity, Zero State, and Upper Bound
    ensures (if (1.0 + K_a * p) == 0.0 then 0.0 else (q_max * K_a * p) / (1.0 + K_a * p)) >= 0.0
    ensures (p == 0.0) ==> ((if (1.0 + K_a * p) == 0.0 then 0.0 else (q_max * K_a * p) / (1.0 + K_a * p)) == 0.0)
    ensures (if (1.0 + K_a * p) == 0.0 then 0.0 else (q_max * K_a * p) / (1.0 + K_a * p)) < q_max
    // Constraint C: Monotonicity
    ensures (p_b > p) ==> (
        (if (1.0 + K_a * p_b) == 0.0 then 0.0 else (q_max * K_a * p_b) / (1.0 + K_a * p_b)) >
        (if (1.0 + K_a * p) == 0.0 then 0.0 else (q_max * K_a * p) / (1.0 + K_a * p))
    )


lemma {:axiom} lemma_langmuir2_rules(p: real, p_b: real, q_max1: real, K_a1: real, q_max2: real, K_a2: real)
    requires p >= 0.0 && p_b >= 0.0 && q_max1 > 0.0 && K_a1 > 0.0 && q_max2 > 0.0 && K_a2 > 0.0
    // Constraints A & B: Positivity, Zero State, and Upper Bound
    ensures (if (1.0 + K_a1 * p == 0.0) || (1.0 + K_a2 * p == 0.0) then 0.0 else ((q_max1 * K_a1 * p) / (1.0 + K_a1 * p)) + ((q_max2 * K_a2 * p) / (1.0 + K_a2 * p))) >= 0.0
    ensures (p == 0.0) ==> ((if (1.0 + K_a1 * p == 0.0) || (1.0 + K_a2 * p == 0.0) then 0.0 else ((q_max1 * K_a1 * p) / (1.0 + K_a1 * p)) + ((q_max2 * K_a2 * p) / (1.0 + K_a2 * p))) == 0.0)
    ensures (if (1.0 + K_a1 * p == 0.0) || (1.0 + K_a2 * p == 0.0) then 0.0 else ((q_max1 * K_a1 * p) / (1.0 + K_a1 * p)) + ((q_max2 * K_a2 * p) / (1.0 + K_a2 * p))) < (q_max1 + q_max2)
    // Constraint C: Monotonicity
    ensures (p_b > p) ==> (
        (if (1.0 + K_a1 * p_b == 0.0) || (1.0 + K_a2 * p_b == 0.0) then 0.0 else ((q_max1 * K_a1 * p_b) / (1.0 + K_a1 * p_b)) + ((q_max2 * K_a2 * p_b) / (1.0 + K_a2 * p_b))) >
        (if (1.0 + K_a1 * p == 0.0) || (1.0 + K_a2 * p == 0.0) then 0.0 else ((q_max1 * K_a1 * p) / (1.0 + K_a1 * p)) + ((q_max2 * K_a2 * p) / (1.0 + K_a2 * p)))
    )




// =======STUB CODE ENDS==============



method agent(x: real) returns (r: real)
    requires (0.0 <= x <= 5.0)
    ensures r >= 0.0
    ensures (r >= (x + 1.0))
 // (x+1)**3/(x**2-x+1)
{
    var denominator: real := x*x - x + 1.0;
    assert denominator > 0.0; // for x in [0,5], x^2 - x + 1 > 0
    var numerator: real := (x*x + 2.0*x + 1.0); // (x+1)^2
    assert numerator >= denominator;
    var temp: real :=  numerator / denominator;
    assert temp >= 1.0;
    r := temp;
    assert r >= 1.0;
    r := r * (x + 1.0); // multiply by (x+1)
    assert r >= (x + 1.0);
}
